var store = [{
        "title": "Go에서 HashSet 구현하기",
        "excerpt":"12월 18일 기준 가장 최근 버전인 Go 1.17에도 아직 Set이라는 자료구조가 없다. 알고리즘 문제나 Advent of Code 문제를 풀 때 Set을 필요로 하는 경우가 생각보다 많았어서 직접 구현해보았다. Set이라는 자료구조를 통해 얻고 싶어하는 기능들을 아래와 같다.   데이터를 중복 없이 관리하고 싶을 때  데이터를 쉽게 추가하고 제거하는 기능이 필요할 때  데이터를 적은 공간 복잡도를 가진 자료구조에서 관리하고 싶을 때그리고 이러한 기능들은 Go 언어에서 제공하는 map을 사용하면 아래와 같이 간단하게 구현할 수 있다. type set map[interface{}]struct{}실제로 사용할 때는 interface{}를 추가하고 싶은 데이터의 자료형으로 변경해서 사용하면 된다. (e.g: type set map[string]struct{}) Go에서 map은 HashTable을 구현해놓은 것이기 때문에 key는 중복될 수 없고 데이터를 추가하고 제거하는 것은 O(1)으로 매우 빠르다. 그리고 빈 struct{}는 0바이트이기 때문에 메모리 사용도 최소화할 수 있다. 만약 위의 타입을 그냥 사용하는 것이 다른 동료 개발자들을 헷갈리게 할 것 같다면 아래와 같이 set에 함수들을 추가하는 것으로 해결할 수 있다. func (s set) Add(v interface{}) {\ts[v] = struct{}{}}func (s set) Remove(v interface{}) {\tdelete(s, v)}func (s set) Contain(v interface{}) bool {\t_, ok := s[v]\treturn ok}func (s set) Length() int {\treturn len(s)}위의 코드들은 Go Playground에서 직접 사용해보실 수 있다. ","categories": ["Golang"],
        "tags": ["golang","data structure"],
        "url": "https://whyjun.github.io/golang/Write-Hashset-In-Go"
      },{
        "title": "Go에서 Enum 사용하기 그리고 주의할 점",
        "excerpt":"Go 언어는 enum 타입을 제공하지 않지만 Enum으로 사용할 데이터 타입을 따로 생성 후 iota를 이용해서 비슷하게 사용할 수 있다. (예시 코드) package mainimport \"fmt\"type level inttype Status intconst (\teasy level = iota + 1\tmedium\thard)const (\tStatusUnknown Status = iota\tStatusOK\tStatusError)func main() {\tlevelList := []level{easy, medium, hard}\tfmt.Println(levelList)\t// Output: [1 2 3]\tstatusList := []Status{StatusUnknown, StatusOK, StatusError}\tfmt.Println(statusList)\t// Output: [0 1 2]}주의할 점은 iota가 항상 0 부터 시작하기 때문에 enum의 첫 값을 iota + 1으로 해서 1 부터 시작하도록 하던지 아니면 첫 enum을 Unknown이나 Nil을 나타내는데 사용해야 한다. Go의 Zero Value때문에 예상치 못한 부작용이 생길 수 있기 때문이다. 이벤트 큐에서 아래와 같은 JSON 형식의 request를 받는 시스템이 있다고 가정해보자. type Request struct {\tID        int    `json:\"ID\"`\tTimestamp int    `json:\"Timestamp\"`\tMessage   string `json:\"Message\"`\tStatus    Status `json:\"Status\"`}만약 이 Request를 보내는 코드에서 아래와 같이 Status를 JSON에 넣는 것을 까먹고 보냈다면 어떻게 될까? {  \"ID\": 1,  \"Timestamp\": 1641775651,  \"Message\": \"Example message\"}Status 필드에 아무런 데이터가 들어가있지 않기 때문에 Request의 Status 값은 int의 Zero Value인 0이 될 것이다. 첫 enum이 StatusUnknown이 아니라 StatusOK였다면 Status 데이터가 없는 모든 Request들은 아무도 모르게 버그를 일으킬 것이다. 그렇기 때문에 Go에서 enum을 사용할 때는 Zero Value를 염두에 두고 꼭 첫 enum을 Unknown이나 Nil을 나타내는 값으로 지정하는 습관을 가져야 한다. ","categories": ["Golang"],
        "tags": ["golang"],
        "url": "https://whyjun.github.io/golang/Enum-in-Golang"
      },{
        "title": "golangcli-lint로 Go 코드 규칙 적용하기",
        "excerpt":"개발팀 사이즈가 커지면서 관리해야 하는 리포지토리의 개수가 늘어났고 각각의 프로젝트가 팀을 리드하는 개발자에 따라 자유분방한 모습으로 진화했습니다. 특히 Go 언어를 처음으로 사용하는 개발자들이 늘어나면서 코드 리뷰 과정에서 Idiomatic Go에 대해서 설명하고 작성하는데 시간을 꽤 소모하게 되었습니다. 그러다보니 실제로 리뷰가 되어야 하는 부분보다 더 많은 시간을 쏟게 되는 경우가 늘어났고 이를 방지하기 위해 자동화된 도구가 필요하다라는 피드백이 나오기 시작했습니다. 다행히도 Go 커뮤니티에는 다양한 Lint 도구들이 이미 개발되어 있었는데 대표적으로 govet, gofmt, golint 등이 있습니다. 이러한 도구들은 좋은 Go 코드를 작성하기 위해 필요한 부분들을 다 체크하지만 각각 따로 돌려야 한다는 단점이 있습니다. 이러한 단점을 극복하기 위해 저희 팀은 golangci-lint를 사용하기로 했습니다. golangci-lint는 Lint 도구는 아니지만 다양한 Lint 도구들을 한번에 돌릴 수 있게 도와줍니다. 단순히 도구들을 순서대로 돌리는 것이 아니라 병렬적으로 돌리는 동시에 분석 결과값을 캐싱함으로써 정적 분석을 매우 빠르게 끝낼 수 있습니다. 그리고 회사에 많은 개발자들이 사용하고 있는 Visual Studio Code를 지원하고 이 점을 활용해 settings.json에 설정 몇 가지를 추가하는 것으로 코드 규칙을 지키지 않을 경우 Warning 메세지를 바로 띄워주어 개발자들이 빠르게 고칠 수 있게 도와줍니다.  설치하기 Mac과 Windows가 아닌 다른 환경에서 설치하는 방법은 공식 문서에 자세히 나와있습니다. Mac brew install golangci-lintbrew upgrade golangci-lintgolangci-lint versionWindows # Git for Windows를 설치할 때 같이 설치되는 Git Bash에 아래 명령어를 입력하시면 설치됩니다.# 실제 binary는 $(go env GOPATH)/bin/golangci-lint에 있습니다curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin golangci-lint --version사용하기 golangci-lint run위 명령어를 입력하면 golangci-lint 기본으로 설정되어 있는 Lint 도구들로 코드를 분석합니다. 어떠한 도구들을 사용하는지 확인하고 싶으면 golangci-lint help linters로 확인할 수 있습니다. golangci-lint를 직접 설정하고 싶다면 공식 문서를 참고해서 .golangci.yml 파일을 작성하시면 됩니다. Visual Studio Code에 추가하기 Visual Studio Code 설정에 들어가서 settings.json을 연 다음, 아래 설정을 추가하면 Visual Studio Code에서 Warning 메세지를 확인할 수 있습니다. \"go.lintTool\": \"golangci-lint\"\"go.lintFlags\": [    \"--fast\"]사용 후기 실제로 적용해보니 코드 리뷰로 잡아내지 못한 이슈들이 꽤 있었습니다. 대표적으로 error를 fmt.Errorf로 래핑할 때, %w를 사용하지 않았던 부분입니다. errors 패키지를 잘 활용하지 않았다보니 알아차리지 못했지만 프로젝트의 사이즈가 커지면서 어떤 error인지를 확인해야 하는 경우가 빈번하게 발생했는데 %w가 아닌 %s나 %v를 사용했을 때는 errors.UnWrap() 함수를 사용할 수 없고 그 때문에 errors.Is와 errors.As도 활용할 수 없다는 것을 알게 되었습니다. 이처럼 Linter는 하나의 정해진 코드 규칙을 모든 개발자가 지킬 수 있게 해준다는 점을 넘어서 코드에 있는 버그들을 개발자들이 일찍 알아차릴 수 있게 해줍니다. ","categories": ["Golang"],
        "tags": ["golang"],
        "url": "https://whyjun.github.io/golang/Use-GolangCI-Lint"
      },{
        "title": "Go에서 omitempty 태그 사용하기",
        "excerpt":"Go로 웹 서버를 개발하다 보면 JSON 데이터를 주고 받는 경우가 많이 있습니다. struct를 JSON으로 바꿀 때 값이 Zero Value(각 type별 기본 값)이거나 nil인 경우 그 값을 보내지 않아야할 때가 있습니다. 이런 경우, omitempty 태그를 활용하면 JSON에서 쉽게 생략할 수 있습니다. struct 필드에 omitempty 태그가 있다면, Go 언어의 JSON 인코더는 그 필드의 값이 Zero Value거나 nil일 때 그 필드를 생략합니다. 이는 JSON으로 데이터를 보내고 받는 API를 개발할 때 유용하고 특히 JSON 메세지의 사이즈를 줄일 수 있다는 장점이 있습니다. omitempty 태그 struct의 omitempty 태그는 아래와 같이 필드 type 뒤에 Backtick(`)안에 작성해 추가할 수 있습니다. type Person struct {    Name      string `json:\"name,omitempty\"`    Age       int    `json:\"age,omitempty\"`    Address   string `json:\"address,omitempty\"`    Telephone string `json:\"telephone,omitempty\"`}위의 예시를 보면 모든 필드에 omitempty 태그가 있는 것을 볼 수 있습니다. 이는 필드의 값이 Zero Value라면 JSON 형식으로 데이터를 변경할 때 필드가 사라짐을 의미합니다. 예를 들어 아래의 값을 가진 Person 인스턴스가 있다고 합시다. p := Person{    Name:      \"John\",    Age:       0,    Address:   \"\",    Telephone: \"123-456-7890\",}Person을 json.Marshal 함수를 사용해서 JSON으로 바꾼다면 결과값은 아래와 같이 나옵니다. {    \"name\": \"John\",    \"telephone\": \"123-456-7890\"}위에서 볼 수 있듯이, Age와 Address 필드가 사라진 것을 확인할 수 있습니다. ","categories": ["Golang"],
        "tags": ["golang"],
        "url": "https://whyjun.github.io/golang/Golang-Omitempty-Tag"
      },{
        "title": "The Importance of Signals from Test Codes",
        "excerpt":"When you write test code, it can tell you a lot about your main code. If you find it hard to write tests, it often means there are problems in your code design. Let’s explore why these signals are important and what they can teach you. Why Test Codes Matter Test codes are like a mirror for your main code. They show you its strengths and weaknesses. Here are some key signals to watch for:   Difficulty Writing Tests: If you struggle to write tests, your code might be too complex or not modular.  Excessive Mocking: If you need to mock too many things, your code might be tightly coupled.  Long Setup Times: If setting up a test takes a long time, your code may have too many dependencies.  Hidden Dependencies: If certain dependencies are not obvious, your code might be hard to maintain or extend.Key Signals and What They Mean Excessive Mocking   What It Is: Mocking means creating fake objects that mimic real ones.  The Signal: Needing too many mocks usually means your classes are too dependent on each other.  The Solution: Improve your code design. Break down large classes into smaller, independent ones.Long Setup Times   What It Is: Setting up tests should be quick and easy.  The Signal: Long setup times can mean your code has too many dependencies or lacks modularity.  The Solution: Simplify your code. Use dependency injection to reduce setup complexity.Difficulty Isolating Tests   What It Is: Each test should run independently.  The Signal: If tests affect each other, your code might have hidden dependencies.  The Solution: Make your code more modular. Ensure each part of your code does one thing well.Hidden Dependencies   What It Is: Hidden dependencies are those that are not immediately obvious, such as using Instant.now directly within a method.  The Signal: If you find that certain parts of your code rely on hidden dependencies, it’s hard to write unit tests without mocks.  The Solution: Use dependency inversion. For example, instead of setting the current timestamp using Instant.now directly, inject a clock interface and use it to get the current time. This decouples your code from the specific implementation and makes it easier to test.Implementing Dependency Inversion Here’s a practical example to illustrate how to handle hidden dependencies using dependency inversion: Before: public class Event {    private Instant timestamp;    public Event() {        this.timestamp = Instant.now();    }}After: public interface Clock {    Instant now();}public class SystemClock implements Clock {    public Instant now() {        return Instant.now();    }}public class FakeClock implements Clock {    public Instant now() {        return Instant.parse(\"2007-12-03T10:15:30.00Z\");    }}public class Event {    private Instant timestamp;    public Event(Clock clock) {        this.timestamp = clock.now();    }}Benefits of Listening to These Signals By paying attention to these signals, you can improve your code design. This makes your code:   Easier to Understand: Clear, modular code is easier to read and maintain.  More Reliable: Well-designed code has fewer bugs and is easier to test.  More Flexible: Good design makes it easier to add new features.Practical Steps to Improve Your Code   Refactor Regularly: Don’t wait until your code is a mess. Refactor as you go to keep your code clean.  Use Dependency Injection: This reduces the need for mocks and makes your code more modular.  Write Small, Focused Functions: Each function should do one thing and do it well. This makes them easier to test.  Identify and Eliminate Hidden Dependencies: Use patterns like port-adapter and dependency inversion to decouple your code.Conclusion Test codes are valuable tools. They don’t just check if your code works; they also show you where it needs improvement. By paying attention to the signals from your test codes, you can make your code more robust, easier to maintain, and more enjoyable to work with. Keep your tests simple, listen to what they’re telling you, and your code will thank you. ","categories": ["development"],
        "tags": ["test"],
        "url": "https://whyjun.github.io/blog/The-Importance-of-Signals-from-Test-Codes"
      },{
        "title": "Using Interface for Controller Requests in Java Spring Framework",
        "excerpt":"When building a REST API with Java Spring Framework, handling multiple types of requests efficiently can be challenging. One effective approach is to use interfaces for controller requests. In this blog post, we’ll walk through an example using a restaurant order system. We’ll handle different types of orders (like hamburger and pizza) with a single endpoint. Scenario: Restaurant Order System Imagine we have an endpoint /v1/orders that accepts different types of orders. Each order type has some common fields, but also unique fields. We’ll use an interface called Order and implement it with specific classes for each order type. Let’s dive in. Step 1: Define the Order Interface First, we create an Order interface with common fields that all orders will have. public interface Order {    String getOrderType();}Step 2: Implement Order Types Next, we create classes for specific order types, like HamburgerOrder and PizzaOrder. import lombok.Data;import javax.validation.constraints.NotNull;@Datapublic class HamburgerOrder implements Order {    @NotNull    private String orderType = \"hamburger\";    @NotNull    private String bunType;    @NotNull    private String meatType;    private boolean extraCheese;}import lombok.Data;import javax.validation.constraints.NotNull;@Datapublic class PizzaOrder implements Order {    @NotNull    private String orderType = \"pizza\";    @NotNull    private String crustType;    @NotNull    private String size;    private boolean extraToppings;}Step 3: Create the Controller Now, we create the controller to handle the /v1/orders POST request. We’ll use @RequestBody and @Valid annotations to ensure the request body is correctly validated. import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.*;import javax.validation.Valid;@RestController@RequestMapping(\"/v1/orders\")@Validatedpublic class OrderController {    @PostMapping    public ResponseEntity&lt;String&gt; createOrder(@Valid @RequestBody Order order) {        if (order instanceof HamburgerOrder) {            HamburgerOrder hamburgerOrder = (HamburgerOrder) order;            // Process hamburger order            return new ResponseEntity&lt;&gt;(\"Hamburger order received\", HttpStatus.OK);        } else if (order instanceof PizzaOrder) {            PizzaOrder pizzaOrder = (PizzaOrder) order;            // Process pizza order            return new ResponseEntity&lt;&gt;(\"Pizza order received\", HttpStatus.OK);        } else {            return new ResponseEntity&lt;&gt;(\"Unknown order type\", HttpStatus.BAD_REQUEST);        }    }}Step 4: Configure Jackson for Polymorphic Deserialization To handle polymorphic deserialization, we need to configure Jackson. This allows us to deserialize JSON into the correct Order implementation. import com.fasterxml.jackson.annotation.JsonSubTypes;import com.fasterxml.jackson.annotation.JsonTypeInfo;@JsonTypeInfo(        use = JsonTypeInfo.Id.NAME,        include = JsonTypeInfo.As.PROPERTY,        property = \"orderType\")@JsonSubTypes({        @JsonSubTypes.Type(value = HamburgerOrder.class, name = \"hamburger\"),        @JsonSubTypes.Type(value = PizzaOrder.class, name = \"pizza\")})public interface Order {    String getOrderType();}Step 5: Add Global Validation Handling Finally, add global exception handling to manage validation errors. import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;@ControllerAdvicepublic class GlobalExceptionHandler {    @ExceptionHandler(MethodArgumentNotValidException.class)    public ResponseEntity&lt;String&gt; handleValidationExceptions(MethodArgumentNotValidException ex) {        return new ResponseEntity&lt;&gt;(\"Invalid order data\", HttpStatus.BAD_REQUEST);    }}Conclusion Using interfaces for controller requests in Java Spring Framework allows you to handle multiple types of requests cleanly and efficiently. In this example, we created an Order interface and implemented specific order types, handled polymorphic deserialization with Jackson, and ensured validation with @Valid and @RequestBody. This approach makes your code more flexible and easier to maintain. Happy coding! ","categories": ["development"],
        "tags": ["java"],
        "url": "https://whyjun.github.io/blog/Using-Interface-for-Controller-Requests-in-Java%20Spring-Framework"
      },{
        "title": "Storing Heterogeneous Objects in PostgreSQL",
        "excerpt":"Storing different types of objects in a PostgreSQL database can be tricky. But don’t worry, it’s manageable. Let’s explore three practical ways to handle this. We will keep it simple and straightforward. Scenario: Restaurant Order System Imagine we have a Transaction table that stores different types of orders. Each order type has some common fields, but also unique fields. Using JSONB for Orders The JSONB data type is flexible. It allows you to store various order types without much hassle. Schema CREATE TABLE transactions (    id SERIAL PRIMARY KEY,    orders JSONB);Inserting Data You can insert data by converting orders to JSON. INSERT INTO transactions (orders) VALUES (    '[        {\"type\": \"HamburgerOrder\", \"field1\": \"value1\", \"field2\": \"value2\"},        {\"type\": \"PizzaOrder\", \"field1\": \"value1\", \"field2\": \"value2\", \"uniqueField\": \"uniqueValue\"}    ]'::jsonb);Querying Data Retrieving specific orders is easy. SELECT * FROM transactionsWHERE orders @&gt; '[{\"type\": \"HamburgerOrder\"}]';Pros and Cons   Pros: Very flexible. Simple schema.  Cons: Complex queries. Limited data validation.Using a Normalized Schema This method involves multiple tables and foreign keys. It keeps the database structure clean and efficient. Schema Transactions Table: CREATE TABLE transactions (    id SERIAL PRIMARY KEY);Orders Table: CREATE TABLE orders (    id SERIAL PRIMARY KEY,    transaction_id INT REFERENCES transactions(id),    type VARCHAR(50) NOT NULL,    common_field1 TEXT,    common_field2 TEXT);HamburgerOrder Table: CREATE TABLE hamburger_orders (    id SERIAL PRIMARY KEY,    order_id INT REFERENCES orders(id),    unique_hamburger_field TEXT);PizzaOrder Table: CREATE TABLE pizza_orders (    id SERIAL PRIMARY KEY,    order_id INT REFERENCES orders(id),    unique_pizza_field TEXT);Inserting Data Insert data step-by-step. INSERT INTO transactions DEFAULT VALUES RETURNING id;INSERT INTO orders (transaction_id, type, common_field1, common_field2) VALUES(1, 'HamburgerOrder', 'value1', 'value2') RETURNING id;INSERT INTO hamburger_orders (order_id, unique_hamburger_field) VALUES(1, 'hamburgerValue');Querying Data Use JOIN queries to get all orders. SELECT o.id AS order_id, o.type, o.common_field1, o.common_field2,       h.unique_hamburger_field, p.unique_pizza_fieldFROM orders oLEFT JOIN hamburger_orders h ON o.id = h.order_idLEFT JOIN pizza_orders p ON o.id = p.order_idWHERE o.transaction_id = 1;Pros and Cons   Pros: Strong data integrity. Efficient querying.  Cons: More complex schema. Requires more tables.Hybrid Approach: Common Fields + JSONB This approach combines the best of both worlds. Common fields are stored directly in columns. Unique fields go into a JSONB column. Schema CREATE TABLE orders (    id SERIAL PRIMARY KEY,    transaction_id INT REFERENCES transactions(id),    type VARCHAR(50) NOT NULL,    common_field1 TEXT,    common_field2 TEXT,    specific_fields JSONB);Inserting Data Insert data with common fields and JSONB. INSERT INTO orders (transaction_id, type, common_field1, common_field2, specific_fields) VALUES(1, 'HamburgerOrder', 'value1', 'value2', '{\"unique_hamburger_field\": \"hamburgerValue\"}'::jsonb),(1, 'PizzaOrder', 'value1', 'value2', '{\"unique_pizza_field\": \"pizzaValue\"}'::jsonb);Querying Data Query directly from the orders table. SELECT * FROM orders WHERE transaction_id = 1;Pros and Cons   Pros: Flexibility with JSONB. Easier querying for common fields.  Cons: Validation can be tricky. Slightly more complex.Conclusion Choosing the right method depends on your needs. JSONB is flexible but validation can be tricky. A normalized schema ensures data integrity but requires more tables. The hybrid approach offers a balanced solution. Each method has its pros and cons. Pick the one that fits your project best. Happy coding! ","categories": ["development"],
        "tags": ["java","sql"],
        "url": "https://whyjun.github.io/blog/Storing-Heterogeneous-Objects-in-PostgreSQL"
      }]
